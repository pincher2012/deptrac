{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Deptrac? Deptrac is a static code analysis tool for PHP that helps you communicate, visualize and enforce architectural decisions in your projects. You can freely define your architectural layers over classes and which rules should apply to them. For example, you can use Deptrac to ensure that bundles/modules/extensions in your project are truly independent of each other to make them easier to reuse. Deptrac can be used in a CI pipeline to make sure a pull request does not violate any of the architectural rules you defined. With the optional Graphviz formatter you can visualize your layers, rules and violations. Requirements In order to run Deptrac you need at least PHP 7.4. We also support PHP 8. You can analyse projects that require an older PHP version as long as nikic/php-parser can parse it. Installation While you can install Deptrac using composer, we recommend using either the phar installation or PHIVE. This will ensure that Deptrac and its dependencies are bundled together and will not interfere with any of your project's dependencies. PHAR Download the latest deptrac.phar . You can run the phar file using php: php deptrac.phar analyse All examples in this documentation, assume you have the deptrac.phar downloaded in your project's root directory as described above. Feel free to add Deptrac to your PATH (i.e. /usr/local/bin/deptrac ) to make it globally available. curl -LS https://github.com/qossmic/deptrac/releases/download/0.19.1/deptrac.phar -o deptrac.phar # optional sudo chmod +x deptrac.phar sudo mv deptrac.phar /usr/local/bin/deptrac PHIVE You can install Deptrac with Phive phive install -g qossmic/deptrac and accept the key with fingerprint 41DD E075 4745 9FAE CFA1 7813 B8F6 4013 4AB1 782E . To upgrade Deptrac use the following command: phive update -g qossmic/deptrac Composer We do not recommend installing this repository via Composer. Instead, please use the dedicated distribution repository https://github.com/qossmic/deptrac-shim. When you install Deptrac using the qossmic/deptrac-shim package, you will get the benefit of using the phar installation, but you can use it like any other composer dependency, i.e. you run Deptrac like this: composer require qossmic/deptrac-shim php vendor/bin/deptrac analyse Optional Dependency: Graphviz If you want to create graphical diagrams with your class dependencies, you will also need the dot command provided by Graphviz . Graphviz can be installed using common package managers: # for macos + brew brew install graphviz # for ubuntu and debian sudo apt-get install graphviz Graphviz is also available for Windows . Install the current stable release and append the binary path on the environment variable Path (e.g. C:\\Program Files (x86)\\Graphviz2.38\\bin ). Getting Started In order to get started with Deptrac you will need a configuration file, called depfile . This configuration file is written in YAML and, by default, is stored with the name depfile.yaml in your project's root directory. Deptrac can generate a template for you, using the init command. php deptrac.phar init The main purpose of this file is: Define in which directories Deptrac will search for classes and which files to exclude. Define your architectural layers using so-called collectors. Define a ruleset describing which layers can communicate with each other. You can find out more about the Core Concepts in the docs. The Depfile Let's have a look at the generated file: # depfile.yaml paths: - ./src exclude_files: - '#.*test.*#' layers: - name: Controller collectors: - type: className regex: .*Controller.* - name: Repository collectors: - type: className regex: .*Repository.* - name: Service collectors: - type: className regex: .*Service.* ruleset: Controller: - Service Service: - Repository Repository: ~ By default, Deptrac will search your project's src/ directory for classes and will ignore any files and directory having test in it. We then define three layers by searching for class names in the files found by Deptrac. Any file containing a class with Controller will be grouped in a layer with the same name. The same happens for classes having Repository and Service in their name. It is important to note that the fully qualified class name is used for grouping classes. That means, the collector will take the full namespace into account. The default ruleset will then allow classes in the Controller-layer to communicate - i.e. use classes from - the Service layer. Classes grouped in the Service layer may not use classes from the Controller layer, but they can use classes from the Repository layer. Classes inside the Repository layer may not use any classes from the other two layers. You can learn more about the file in the Depfile reference . Run Deptrac Once you have set up the depfile you can run Deptrac to analyse your code and check for violations. php deptrac.phar # which is equivalent to php deptrac.phar analyse --config-file=deptrac.yaml If you run php deptrac.phar -v you'll get a more verbose output. The analyse command runs with a caching mechanism for parsed files by default. This can be disabled with the --no-cache option. The generated output will roughly look like this: ----------- -------------------------------------------------------------------------------------------------------------------------------- Reason Repository ----------- -------------------------------------------------------------------------------------------------------------------------------- Violation examples\\MyNamespace\\Repository\\SomeRepository must not depend on examples\\MyNamespace\\Controllers\\SomeController (Controller) /Users/dbr/workspace/qossmic/deptrac/examples/ControllerServiceRepository1/SomeRepository.php:5 ----------- -------------------------------------------------------------------------------------------------------------------------------- -------------------- ----- Report -------------------- ----- Violations 1 Skipped violations 0 Uncovered 0 Allowed 4 Warnings 0 Errors 0 -------------------- ----- This is a report generated by Deptrac. At the top you can see a list of violations, if there are any. A violation means, that a layer uses a layer that is prohibited by the configured ruleset. In this case, a class from the Repository layer uses a class from the Controller layer. The table on the bottom gives you an overview over: how many violations were found. how many violations were skipped, meaning your depfile contains exceptions. which will not cause Deptrac to return with an error status code, e.g. in CI, when these violations are found. how many classes were found in the directories, that were not assigned to a layer. how many usages between layers were found that do not violate the ruleset. how many warnings where encountered, e.g. because a class is grouped in multiple layers. how many errors were encountered, e.g. when you exclude a violation in your depfile but that violation is not encountered. If the output does not match your expectations please take a look at the debugging commands available in Deptrac. You can also change the output format itself by using one of the many provided Output Formatters . Contribute Deptrac is in active development. We are looking for your suggestions and help to make it better. Feel free to open an issue if you encounter bugs, have suggestions or would like to add a new feature to Deptrac. Please feel free to improve this documentation, fix bugs, or work on a suggested feature by making a pull request on GitHub. Don't hesitate to ask for support, if you need help at any point. The Contribution Guide in the documentation contains some advice for making a pull request with code changes. Code of Conduct If you are professional and polite then everything will be alright. Please don't be inconsiderate or mean, or anything in between. Further Documentation Core Concepts - explains layers, rules and violations in more details. Depfile - reference for all available settings in a depfile Collectors - reference for which collectors are available in Deptrac to define your layers. Formatters - lists the different output formats supported by Deptrac Debugging - overview of the debug commands Contribute - advice for contributing code changes, e.g. how to run tests or how to build a phar file with your changes that you can use to analyse your projects","title":"Home"},{"location":"#what-is-deptrac","text":"Deptrac is a static code analysis tool for PHP that helps you communicate, visualize and enforce architectural decisions in your projects. You can freely define your architectural layers over classes and which rules should apply to them. For example, you can use Deptrac to ensure that bundles/modules/extensions in your project are truly independent of each other to make them easier to reuse. Deptrac can be used in a CI pipeline to make sure a pull request does not violate any of the architectural rules you defined. With the optional Graphviz formatter you can visualize your layers, rules and violations.","title":"What is Deptrac?"},{"location":"#requirements","text":"In order to run Deptrac you need at least PHP 7.4. We also support PHP 8. You can analyse projects that require an older PHP version as long as nikic/php-parser can parse it.","title":"Requirements"},{"location":"#installation","text":"While you can install Deptrac using composer, we recommend using either the phar installation or PHIVE. This will ensure that Deptrac and its dependencies are bundled together and will not interfere with any of your project's dependencies.","title":"Installation"},{"location":"#phar","text":"Download the latest deptrac.phar . You can run the phar file using php: php deptrac.phar analyse All examples in this documentation, assume you have the deptrac.phar downloaded in your project's root directory as described above. Feel free to add Deptrac to your PATH (i.e. /usr/local/bin/deptrac ) to make it globally available. curl -LS https://github.com/qossmic/deptrac/releases/download/0.19.1/deptrac.phar -o deptrac.phar # optional sudo chmod +x deptrac.phar sudo mv deptrac.phar /usr/local/bin/deptrac","title":"PHAR"},{"location":"#phive","text":"You can install Deptrac with Phive phive install -g qossmic/deptrac and accept the key with fingerprint 41DD E075 4745 9FAE CFA1 7813 B8F6 4013 4AB1 782E . To upgrade Deptrac use the following command: phive update -g qossmic/deptrac","title":"PHIVE"},{"location":"#composer","text":"We do not recommend installing this repository via Composer. Instead, please use the dedicated distribution repository https://github.com/qossmic/deptrac-shim. When you install Deptrac using the qossmic/deptrac-shim package, you will get the benefit of using the phar installation, but you can use it like any other composer dependency, i.e. you run Deptrac like this: composer require qossmic/deptrac-shim php vendor/bin/deptrac analyse","title":"Composer"},{"location":"#optional-dependency-graphviz","text":"If you want to create graphical diagrams with your class dependencies, you will also need the dot command provided by Graphviz . Graphviz can be installed using common package managers: # for macos + brew brew install graphviz # for ubuntu and debian sudo apt-get install graphviz Graphviz is also available for Windows . Install the current stable release and append the binary path on the environment variable Path (e.g. C:\\Program Files (x86)\\Graphviz2.38\\bin ).","title":"Optional Dependency: Graphviz"},{"location":"#getting-started","text":"In order to get started with Deptrac you will need a configuration file, called depfile . This configuration file is written in YAML and, by default, is stored with the name depfile.yaml in your project's root directory. Deptrac can generate a template for you, using the init command. php deptrac.phar init The main purpose of this file is: Define in which directories Deptrac will search for classes and which files to exclude. Define your architectural layers using so-called collectors. Define a ruleset describing which layers can communicate with each other. You can find out more about the Core Concepts in the docs.","title":"Getting Started"},{"location":"#the-depfile","text":"Let's have a look at the generated file: # depfile.yaml paths: - ./src exclude_files: - '#.*test.*#' layers: - name: Controller collectors: - type: className regex: .*Controller.* - name: Repository collectors: - type: className regex: .*Repository.* - name: Service collectors: - type: className regex: .*Service.* ruleset: Controller: - Service Service: - Repository Repository: ~ By default, Deptrac will search your project's src/ directory for classes and will ignore any files and directory having test in it. We then define three layers by searching for class names in the files found by Deptrac. Any file containing a class with Controller will be grouped in a layer with the same name. The same happens for classes having Repository and Service in their name. It is important to note that the fully qualified class name is used for grouping classes. That means, the collector will take the full namespace into account. The default ruleset will then allow classes in the Controller-layer to communicate - i.e. use classes from - the Service layer. Classes grouped in the Service layer may not use classes from the Controller layer, but they can use classes from the Repository layer. Classes inside the Repository layer may not use any classes from the other two layers. You can learn more about the file in the Depfile reference .","title":"The Depfile"},{"location":"#run-deptrac","text":"Once you have set up the depfile you can run Deptrac to analyse your code and check for violations. php deptrac.phar # which is equivalent to php deptrac.phar analyse --config-file=deptrac.yaml If you run php deptrac.phar -v you'll get a more verbose output. The analyse command runs with a caching mechanism for parsed files by default. This can be disabled with the --no-cache option. The generated output will roughly look like this: ----------- -------------------------------------------------------------------------------------------------------------------------------- Reason Repository ----------- -------------------------------------------------------------------------------------------------------------------------------- Violation examples\\MyNamespace\\Repository\\SomeRepository must not depend on examples\\MyNamespace\\Controllers\\SomeController (Controller) /Users/dbr/workspace/qossmic/deptrac/examples/ControllerServiceRepository1/SomeRepository.php:5 ----------- -------------------------------------------------------------------------------------------------------------------------------- -------------------- ----- Report -------------------- ----- Violations 1 Skipped violations 0 Uncovered 0 Allowed 4 Warnings 0 Errors 0 -------------------- ----- This is a report generated by Deptrac. At the top you can see a list of violations, if there are any. A violation means, that a layer uses a layer that is prohibited by the configured ruleset. In this case, a class from the Repository layer uses a class from the Controller layer. The table on the bottom gives you an overview over: how many violations were found. how many violations were skipped, meaning your depfile contains exceptions. which will not cause Deptrac to return with an error status code, e.g. in CI, when these violations are found. how many classes were found in the directories, that were not assigned to a layer. how many usages between layers were found that do not violate the ruleset. how many warnings where encountered, e.g. because a class is grouped in multiple layers. how many errors were encountered, e.g. when you exclude a violation in your depfile but that violation is not encountered. If the output does not match your expectations please take a look at the debugging commands available in Deptrac. You can also change the output format itself by using one of the many provided Output Formatters .","title":"Run Deptrac"},{"location":"#contribute","text":"Deptrac is in active development. We are looking for your suggestions and help to make it better. Feel free to open an issue if you encounter bugs, have suggestions or would like to add a new feature to Deptrac. Please feel free to improve this documentation, fix bugs, or work on a suggested feature by making a pull request on GitHub. Don't hesitate to ask for support, if you need help at any point. The Contribution Guide in the documentation contains some advice for making a pull request with code changes.","title":"Contribute"},{"location":"#code-of-conduct","text":"If you are professional and polite then everything will be alright. Please don't be inconsiderate or mean, or anything in between.","title":"Code of Conduct"},{"location":"#further-documentation","text":"Core Concepts - explains layers, rules and violations in more details. Depfile - reference for all available settings in a depfile Collectors - reference for which collectors are available in Deptrac to define your layers. Formatters - lists the different output formats supported by Deptrac Debugging - overview of the debug commands Contribute - advice for contributing code changes, e.g. how to run tests or how to build a phar file with your changes that you can use to analyse your projects","title":"Further Documentation"},{"location":"collectors/","text":"Collectors Collectors decide if a node (typically a class) is part of a layer. You can use multiple different collectors for a layer. bool Collector The bool collector allows combining other collectors with or without negation. parameters: layers: - name: Asset collectors: - type: bool must: - type: className regex: .*Foo\\\\.* - type: className regex: .*\\\\Asset.* must_not: - type: className regex: .*Assetic.* Every class contains Foo\\ AND \\Asset and NOT Assetic , will become a part of the Asset layer. className Collector The className collector allows collecting classes by matching their fully qualified name to a simplified regular expression. Any matching class will be added to the assigned layer. parameters: layers: - name: Controller collectors: - type: className regex: .*Controller.* Every class name that matches the regular expression becomes a part of the controller layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i classNameRegex Collector The classNameRegex collector allows collecting classes by matching their fully qualified name to a regular expression. Any matching class will be added to the assigned layer. parameters: layers: - name: Controller collectors: - type: classNameRegex regex: '#.*Controller.*#' Every class name that matches the regular expression becomes a part of the controller layer. directory Collector The directory collector allows collecting classes by matching their file path they are declared in to a simplified regular expression. Any matching class will be added to the assigned layer. parameters: layers: - name: Controller collectors: - type: directory regex: src/Controller/.* Every file path that matches the regular expression src/Controller/.* becomes a part of the controller layer. This collector has predefined delimiters and modifier: #YOUR_EXPRESSION#i extends Collector The extends collector allows collecting classes extending a specified class by matching recursively for a fully qualified class or interface name. parameters: layers: - name: Foo collectors: - type: extends extends: 'App\\SomeClass' functionName Collector The functionName collector allows collecting functions by matching their fully qualified name to a simplified regular expression. Any matching function will be added to the assigned layer. parameters: layers: - name: Foo collectors: - type: functionName regex: .*array_.* implements Collector The implements collector allows collecting classes implementing a specified interface by matching recursively for a fully qualified interface name. parameters: layers: - name: Foo collectors: - type: implements implements: 'App\\SomeInterface' inherits Collector The inherits collector allows collecting classes inheriting from a specified class, whether by implementing an interface, extending another class or by using a trait, by matching recursively for a fully qualified class name. parameters: layers: - name: Foo collectors: - type: inherits inherits: 'App\\SomeInterface' layer Collector This collector collects all the tokens collected by another layer. It is not very useful by itself (unless you want to have tokens in multiple layers), but it is very useful to exclude classes in combination with the bool Collector : parameters: layers: - name: SubDomain collectors: - type: directory regex: src/Domain/Subdomain/.* - name: Domain collectors: - type: bool must: - type: directory regex: src/Domain/.* must_not: - type: layer layer: SubDomain method Collector The method collector allows collecting classes by matching their methods name to a regular expression. Any matching class will be added to the assigned layer. parameters: layers: - name: Foo services collectors: - type: method name: .*foo Every class having a method that matches the regular expression .*foo , e.g. getFoo() or setFoo() becomes a part of the Foo services layer. superglobal Collector The superglobal collector allows collecting superglobal PHP variables matching the specified superglobal name. parameters: layers: - name: Foo collectors: - type: superglobal names: - _POST - _GET uses Collector The uses collector allows collecting classes using a specified trait by matching recursively for a fully qualified trait name. parameters: layers: - name: Foo collectors: - type: uses uses: 'App\\SomeTrait' Custom Collectors You can create custom collectors in your project by implementing the Qossmic\\Deptrac\\Collector\\CollectorInterface . As soon as an unknown collector is referenced in the config file Deptrac will try to load the class in your project. With this you can create collectors specific for your use case. If you would like to make your collector available to others, feel free to contribute it by making a pull request.","title":"Collectors"},{"location":"collectors/#collectors","text":"Collectors decide if a node (typically a class) is part of a layer. You can use multiple different collectors for a layer.","title":"Collectors"},{"location":"collectors/#bool-collector","text":"The bool collector allows combining other collectors with or without negation. parameters: layers: - name: Asset collectors: - type: bool must: - type: className regex: .*Foo\\\\.* - type: className regex: .*\\\\Asset.* must_not: - type: className regex: .*Assetic.* Every class contains Foo\\ AND \\Asset and NOT Assetic , will become a part of the Asset layer.","title":"bool Collector"},{"location":"collectors/#classname-collector","text":"The className collector allows collecting classes by matching their fully qualified name to a simplified regular expression. Any matching class will be added to the assigned layer. parameters: layers: - name: Controller collectors: - type: className regex: .*Controller.* Every class name that matches the regular expression becomes a part of the controller layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i","title":"className Collector"},{"location":"collectors/#classnameregex-collector","text":"The classNameRegex collector allows collecting classes by matching their fully qualified name to a regular expression. Any matching class will be added to the assigned layer. parameters: layers: - name: Controller collectors: - type: classNameRegex regex: '#.*Controller.*#' Every class name that matches the regular expression becomes a part of the controller layer.","title":"classNameRegex Collector"},{"location":"collectors/#directory-collector","text":"The directory collector allows collecting classes by matching their file path they are declared in to a simplified regular expression. Any matching class will be added to the assigned layer. parameters: layers: - name: Controller collectors: - type: directory regex: src/Controller/.* Every file path that matches the regular expression src/Controller/.* becomes a part of the controller layer. This collector has predefined delimiters and modifier: #YOUR_EXPRESSION#i","title":"directory Collector"},{"location":"collectors/#extends-collector","text":"The extends collector allows collecting classes extending a specified class by matching recursively for a fully qualified class or interface name. parameters: layers: - name: Foo collectors: - type: extends extends: 'App\\SomeClass'","title":"extends Collector"},{"location":"collectors/#functionname-collector","text":"The functionName collector allows collecting functions by matching their fully qualified name to a simplified regular expression. Any matching function will be added to the assigned layer. parameters: layers: - name: Foo collectors: - type: functionName regex: .*array_.*","title":"functionName Collector"},{"location":"collectors/#implements-collector","text":"The implements collector allows collecting classes implementing a specified interface by matching recursively for a fully qualified interface name. parameters: layers: - name: Foo collectors: - type: implements implements: 'App\\SomeInterface'","title":"implements Collector"},{"location":"collectors/#inherits-collector","text":"The inherits collector allows collecting classes inheriting from a specified class, whether by implementing an interface, extending another class or by using a trait, by matching recursively for a fully qualified class name. parameters: layers: - name: Foo collectors: - type: inherits inherits: 'App\\SomeInterface'","title":"inherits Collector"},{"location":"collectors/#layer-collector","text":"This collector collects all the tokens collected by another layer. It is not very useful by itself (unless you want to have tokens in multiple layers), but it is very useful to exclude classes in combination with the bool Collector : parameters: layers: - name: SubDomain collectors: - type: directory regex: src/Domain/Subdomain/.* - name: Domain collectors: - type: bool must: - type: directory regex: src/Domain/.* must_not: - type: layer layer: SubDomain","title":"layer Collector"},{"location":"collectors/#method-collector","text":"The method collector allows collecting classes by matching their methods name to a regular expression. Any matching class will be added to the assigned layer. parameters: layers: - name: Foo services collectors: - type: method name: .*foo Every class having a method that matches the regular expression .*foo , e.g. getFoo() or setFoo() becomes a part of the Foo services layer.","title":"method Collector"},{"location":"collectors/#superglobal-collector","text":"The superglobal collector allows collecting superglobal PHP variables matching the specified superglobal name. parameters: layers: - name: Foo collectors: - type: superglobal names: - _POST - _GET","title":"superglobal Collector"},{"location":"collectors/#uses-collector","text":"The uses collector allows collecting classes using a specified trait by matching recursively for a fully qualified trait name. parameters: layers: - name: Foo collectors: - type: uses uses: 'App\\SomeTrait'","title":"uses Collector"},{"location":"collectors/#custom-collectors","text":"You can create custom collectors in your project by implementing the Qossmic\\Deptrac\\Collector\\CollectorInterface . As soon as an unknown collector is referenced in the config file Deptrac will try to load the class in your project. With this you can create collectors specific for your use case. If you would like to make your collector available to others, feel free to contribute it by making a pull request.","title":"Custom Collectors"},{"location":"concepts/","text":"Core concepts At the heart of Deptrac are three main concepts: Layers are groups of classes that you define Rulesets Describe whether which layers a layer can communicate with, i.e. which classes are allowed in that layer Violations show when a layer uses classes from another layer that is forbidden by the currently configured rulesets. Layers Deptrac allows you to group different tokens(classes, function, file usage outside those) into layers . Technically layers are nothing more than a collection of those tokens. Each layer has a unique name and a list of one or more collectors, which will look for tokens should be assigned to this layer (and yes, tokens can be assigned to more than one layer). If you want to ensure your application follows the MVC architecture pattern then you can create a depfile that makes sure a View does not directly interact with a Controller or that Models are independent of both Views and Controllers. Another example for layers are bundles in Symfony applications. Each bundle should be independent by design. You can create layers for each bundle you have in your application and then ensure that they do not use tokens from any of the other bundles. This is particularly helpful when you have an application with many bundles as it will tell you which ones to consolidate and which ones can be extracted and reused. Deptrac allows you to visualize and enforce a ruleset based on such layer information. So you could define that every class that ends with Controller will be assigned to the Controller layer, and every class that has \\Model\\ in its namespace will be added to the Model layer. By default, all dependencies between layers are forbidden! Collecting Layers If your application has controllers and models , Deptrac allows you to group them into layers. parameters: paths: - ./examples/ModelController exclude_files: ~ layers: - name: Models collectors: - type: className regex: .*MyNamespace\\\\Models\\\\.* - name: Controller collectors: - type: className regex: .*MyNamespace\\\\.*Controller.* ruleset: [ ] At first, lets take a closer look at the first layer (named Models ). Here we decided that our software has some kind of layer called Models . You assign tokens to this layer with the help of Collectors . Collectors are responsible for taking a closer look at your code and decide if a token is part of a layer. By using the className collector you can define a regular expression for a class name. Every (fully qualified) class name that matches this regular expression becomes part of the assigned layer. In this example we define that every class that contains MyNamespace\\Models\\ will be a part of the Model layer. Every class that matches .*MyNamespace\\\\.*Controller.* will become a part of the Controller layer. As we defined our layers, we can generate a dependency graph for the example configuration: (Make sure that Graphviz (dot) is installed on your system) php deptrac.phar analyse --config-file=examples/ModelController1.depfile.yaml After Deptrac has finished, an image should be opened: On your command line Deptrac will produce this output: Start to create an AstMap for 2 Files. .. AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. Found 0 Violations The output shows, that Deptrac is parsing 2 files and found 0 violations. By default, every dependency between layers is a violation. In our case there are (for now) no dependencies between our classes (layers). It's fine that Deptrac will show us two independent layers without any relationship. Ruleset (Allowing Dependencies) Allowed dependencies between layers are configured in a ruleset . By default, Deptrac will raise a violation for every dependency between layers. In real software you want to allow dependencies between different kinds of layers. As a lot of architectures define some kind of controllers , services and repositories , a natural approach for this would be to define these rules: Controllers may access services , but not repositories . Services may access repositories , but not controllers . Repositories neither may access services nor controllers . We can define this using the following depfile: parameters: paths: - ./examples/ControllerServiceRepository1/ exclude_files: ~ layers: - name: Controller collectors: - type: className regex: .*MyNamespace\\\\.*Controller.* - name: Repository collectors: - type: className regex: .*MyNamespace\\\\.*Repository.* - name: Service collectors: - type: className regex: .*MyNamespace\\\\.*Service.* ruleset: Controller: - Service Service: - Repository Repository: ~ Take a closer look at the ruleset. We allow the Controller layer to access Service and Service can access Repository , but Repository may not access any of the two other layers. After running Deptrac we will get this result: Start to create an AstMap for 3 Files. ... AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. examples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller) Deptrac now finds a violation. If we take a closer look at the \"SomeRepository\" on line 5, we will see an unused use statement for a controller: namespace examples\\MyNamespace\\Repository; use examples\\MyNamespace\\Controllers\\SomeController; class SomeRepository { } If we remove the use statement and rerun Deptrac, the violation will disappear. Different Layers and Different Views In the example above we defined 3 different layers ( controller , repository and service ). Deptrac gives architects the power to define what kind of layers exist. Typical use cases are: caring about layers in different architectures (tier, hexagonal, ddd, ...) caring about dependencies between different kinds of services (infrastructure services / domain services / entities / DTOs / ...) caring about coupling to third party code like composer vendors, frameworks, ... enforcing naming conventions ... Typically software has more than just one view. It is possible to use multiple depfiles, to take care about different architectural views. Uncovered dependencies Deptrac collects uncovered dependencies which can be reported with the Console Formatter . By default, internal php classes will not be considered. This can be changed by adding ignore_uncovered_internal_classes: false to your depfile. You can use the --fail-on-uncovered option to let Deptrac fail when any uncovered dependencies are encountered. You can use the --report-uncovered option to let you know about any uncovered dependencies in the report that is generated by Deptrac. Violations If we have 2 layers ( Models , Controller ) and one layer is using the other, Deptrac will raise a violation by default: // see the example in examples/ModelController2 namespace examples\\MyNamespace\\Controllers; use examples\\MyNamespace\\Models\\SomeModel; class SomeController { public function foo(SomeModel $m) { return $m; } } After running Deptrac for this example php deptrac.phar analyse --config-file=examples/ModelController2.depfile.yaml we will get this output: Start to create an AstMap for 2 Files. .. AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. examples\\MyNamespace\\Controllers\\SomeController::5 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models) examples\\MyNamespace\\Controllers\\SomeController::9 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models) Found 2 Violations Deptrac has found two violations because the relation from the controller to model layers is not allowed. The console output shows exactly the lines Deptrac found. Skip violations Deptrac integration into existing CI/CD pipeline might be difficult because of existing dependency violations in the code. In this case, you can skip existing violations to gradually improve your code and avoid possibility introduce any new violations. Violations can be skipped by provided list of dependencies in skip_violations configuration section: parameters: skip_violations: Library\\LibClass: - Core\\CoreClass skip_violations section contains an associative array where a key ( Library\\LibClass ) is the name of dependant token and values ( Core\\CoreClass ) are dependency tokens. Matched violations will be marked as skipped: php deptrac.phar analyse --config-file=examples/SkipViolations.yaml --report-skipped 1/1 [\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593] 100% [SKIPPED] Library\\LibClass must not depend on Core\\CoreClass (Library on Core) /path/examples/SkipViolations/SkipViolations.php::11 [ERROR] Skipped violation \"Core\\Unmatched\" for \"Library\\LibClass\" was not matched. Report: Violations: 0 Skipped violations: 1 Uncovered: 0 Allowed: 1","title":"Concepts"},{"location":"concepts/#core-concepts","text":"At the heart of Deptrac are three main concepts: Layers are groups of classes that you define Rulesets Describe whether which layers a layer can communicate with, i.e. which classes are allowed in that layer Violations show when a layer uses classes from another layer that is forbidden by the currently configured rulesets.","title":"Core concepts"},{"location":"concepts/#layers","text":"Deptrac allows you to group different tokens(classes, function, file usage outside those) into layers . Technically layers are nothing more than a collection of those tokens. Each layer has a unique name and a list of one or more collectors, which will look for tokens should be assigned to this layer (and yes, tokens can be assigned to more than one layer). If you want to ensure your application follows the MVC architecture pattern then you can create a depfile that makes sure a View does not directly interact with a Controller or that Models are independent of both Views and Controllers. Another example for layers are bundles in Symfony applications. Each bundle should be independent by design. You can create layers for each bundle you have in your application and then ensure that they do not use tokens from any of the other bundles. This is particularly helpful when you have an application with many bundles as it will tell you which ones to consolidate and which ones can be extracted and reused. Deptrac allows you to visualize and enforce a ruleset based on such layer information. So you could define that every class that ends with Controller will be assigned to the Controller layer, and every class that has \\Model\\ in its namespace will be added to the Model layer. By default, all dependencies between layers are forbidden!","title":"Layers"},{"location":"concepts/#collecting-layers","text":"If your application has controllers and models , Deptrac allows you to group them into layers. parameters: paths: - ./examples/ModelController exclude_files: ~ layers: - name: Models collectors: - type: className regex: .*MyNamespace\\\\Models\\\\.* - name: Controller collectors: - type: className regex: .*MyNamespace\\\\.*Controller.* ruleset: [ ] At first, lets take a closer look at the first layer (named Models ). Here we decided that our software has some kind of layer called Models . You assign tokens to this layer with the help of Collectors . Collectors are responsible for taking a closer look at your code and decide if a token is part of a layer. By using the className collector you can define a regular expression for a class name. Every (fully qualified) class name that matches this regular expression becomes part of the assigned layer. In this example we define that every class that contains MyNamespace\\Models\\ will be a part of the Model layer. Every class that matches .*MyNamespace\\\\.*Controller.* will become a part of the Controller layer. As we defined our layers, we can generate a dependency graph for the example configuration: (Make sure that Graphviz (dot) is installed on your system) php deptrac.phar analyse --config-file=examples/ModelController1.depfile.yaml After Deptrac has finished, an image should be opened: On your command line Deptrac will produce this output: Start to create an AstMap for 2 Files. .. AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. Found 0 Violations The output shows, that Deptrac is parsing 2 files and found 0 violations. By default, every dependency between layers is a violation. In our case there are (for now) no dependencies between our classes (layers). It's fine that Deptrac will show us two independent layers without any relationship.","title":"Collecting Layers"},{"location":"concepts/#ruleset-allowing-dependencies","text":"Allowed dependencies between layers are configured in a ruleset . By default, Deptrac will raise a violation for every dependency between layers. In real software you want to allow dependencies between different kinds of layers. As a lot of architectures define some kind of controllers , services and repositories , a natural approach for this would be to define these rules: Controllers may access services , but not repositories . Services may access repositories , but not controllers . Repositories neither may access services nor controllers . We can define this using the following depfile: parameters: paths: - ./examples/ControllerServiceRepository1/ exclude_files: ~ layers: - name: Controller collectors: - type: className regex: .*MyNamespace\\\\.*Controller.* - name: Repository collectors: - type: className regex: .*MyNamespace\\\\.*Repository.* - name: Service collectors: - type: className regex: .*MyNamespace\\\\.*Service.* ruleset: Controller: - Service Service: - Repository Repository: ~ Take a closer look at the ruleset. We allow the Controller layer to access Service and Service can access Repository , but Repository may not access any of the two other layers. After running Deptrac we will get this result: Start to create an AstMap for 3 Files. ... AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. examples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller) Deptrac now finds a violation. If we take a closer look at the \"SomeRepository\" on line 5, we will see an unused use statement for a controller: namespace examples\\MyNamespace\\Repository; use examples\\MyNamespace\\Controllers\\SomeController; class SomeRepository { } If we remove the use statement and rerun Deptrac, the violation will disappear.","title":"Ruleset (Allowing Dependencies)"},{"location":"concepts/#different-layers-and-different-views","text":"In the example above we defined 3 different layers ( controller , repository and service ). Deptrac gives architects the power to define what kind of layers exist. Typical use cases are: caring about layers in different architectures (tier, hexagonal, ddd, ...) caring about dependencies between different kinds of services (infrastructure services / domain services / entities / DTOs / ...) caring about coupling to third party code like composer vendors, frameworks, ... enforcing naming conventions ... Typically software has more than just one view. It is possible to use multiple depfiles, to take care about different architectural views.","title":"Different Layers and Different Views"},{"location":"concepts/#uncovered-dependencies","text":"Deptrac collects uncovered dependencies which can be reported with the Console Formatter . By default, internal php classes will not be considered. This can be changed by adding ignore_uncovered_internal_classes: false to your depfile. You can use the --fail-on-uncovered option to let Deptrac fail when any uncovered dependencies are encountered. You can use the --report-uncovered option to let you know about any uncovered dependencies in the report that is generated by Deptrac.","title":"Uncovered dependencies"},{"location":"concepts/#violations","text":"If we have 2 layers ( Models , Controller ) and one layer is using the other, Deptrac will raise a violation by default: // see the example in examples/ModelController2 namespace examples\\MyNamespace\\Controllers; use examples\\MyNamespace\\Models\\SomeModel; class SomeController { public function foo(SomeModel $m) { return $m; } } After running Deptrac for this example php deptrac.phar analyse --config-file=examples/ModelController2.depfile.yaml we will get this output: Start to create an AstMap for 2 Files. .. AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. examples\\MyNamespace\\Controllers\\SomeController::5 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models) examples\\MyNamespace\\Controllers\\SomeController::9 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models) Found 2 Violations Deptrac has found two violations because the relation from the controller to model layers is not allowed. The console output shows exactly the lines Deptrac found.","title":"Violations"},{"location":"concepts/#skip-violations","text":"Deptrac integration into existing CI/CD pipeline might be difficult because of existing dependency violations in the code. In this case, you can skip existing violations to gradually improve your code and avoid possibility introduce any new violations. Violations can be skipped by provided list of dependencies in skip_violations configuration section: parameters: skip_violations: Library\\LibClass: - Core\\CoreClass skip_violations section contains an associative array where a key ( Library\\LibClass ) is the name of dependant token and values ( Core\\CoreClass ) are dependency tokens. Matched violations will be marked as skipped: php deptrac.phar analyse --config-file=examples/SkipViolations.yaml --report-skipped 1/1 [\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593] 100% [SKIPPED] Library\\LibClass must not depend on Core\\CoreClass (Library on Core) /path/examples/SkipViolations/SkipViolations.php::11 [ERROR] Skipped violation \"Core\\Unmatched\" for \"Library\\LibClass\" was not matched. Report: Violations: 0 Skipped violations: 1 Uncovered: 0 Allowed: 1","title":"Skip violations"},{"location":"contributing/","text":"Contributing to Deptrac There are many ways to contribute to Deptrac, from helping others with their issues, improving the documentation to fixing bugs & adding new features. When you want to add a new feature to Deptrac, please make sure to open an issue first to let others know who is working on it and prevent similar or conflicting pull requests. We are always happy to expand the possibilities of Deptrac to better fit the need of anyone who uses it. Before we merge changes, we have to decide whether we can maintain them without taking away resources needed elsewhere. Unfortunately, that means we have to reject some change requests. Opening an issue before you start working on any new feature will make sure that your merge request can be accepted. Requirements PHP in version 7.4 or above Composer PHIVE make Installing tools We do not bundle tools like phpunit as dev-dependencies via composer. Instead, we use PHIVE . You can install all tools needed for developing Deptrac using the Makefile by running the following command: make tools-install If you would rather use composer, then consider installing the dependencies globally using composer global require and make sure to use the appropriate versions. Pipeline Any merge request must pass our build pipeline which consists of the following: Unit Tests for all supported PHP-versions Check for coding guidelines Static code analysis with phpstan and psalm End 2 End-tests, ensuring deptrac.phar can be built You can use the provided Makefile to execute these steps locally. The make command is supported by most major operating systems, but you might need to install it first. The Makefile will use PHIVE to install the required tools like PHPUnit, Psalm or PHPStan. We do not provide these tools as dev-dependencies in composer. If you don't want to use PHIVE or the Makefile you will need to install them yourself. Tests You can run the unit tests locally using the provided Makefile make tests This will run phpunit to make sure the tests pass. We recommend running the tests once before you make any changes to ensure they work on your system. This way you can be sure that any failing test is not caused by a pre-existing problem. Code style You can check if your code changes are in line with our coding guidelines using php-cs-fixer. make php-cs-check This will show you any code style violations that are also reported on Github. You can automatically fix them by running: make php-cs-fix Static code analysis In order to perform static code analysis for your changes you can run: make phpstan make psalm We also run a tool called infection for mutation testing: make infection Build Deptrac You can build the deptrac.phar both to ensure it works, as well as for using it to analyse your existing projects to see if your changes work as expected. make build This will create an executable file deptrac.phar in the current directory.","title":"Contributing"},{"location":"contributing/#contributing-to-deptrac","text":"There are many ways to contribute to Deptrac, from helping others with their issues, improving the documentation to fixing bugs & adding new features. When you want to add a new feature to Deptrac, please make sure to open an issue first to let others know who is working on it and prevent similar or conflicting pull requests. We are always happy to expand the possibilities of Deptrac to better fit the need of anyone who uses it. Before we merge changes, we have to decide whether we can maintain them without taking away resources needed elsewhere. Unfortunately, that means we have to reject some change requests. Opening an issue before you start working on any new feature will make sure that your merge request can be accepted.","title":"Contributing to Deptrac"},{"location":"contributing/#requirements","text":"PHP in version 7.4 or above Composer PHIVE make","title":"Requirements"},{"location":"contributing/#installing-tools","text":"We do not bundle tools like phpunit as dev-dependencies via composer. Instead, we use PHIVE . You can install all tools needed for developing Deptrac using the Makefile by running the following command: make tools-install If you would rather use composer, then consider installing the dependencies globally using composer global require and make sure to use the appropriate versions.","title":"Installing tools"},{"location":"contributing/#pipeline","text":"Any merge request must pass our build pipeline which consists of the following: Unit Tests for all supported PHP-versions Check for coding guidelines Static code analysis with phpstan and psalm End 2 End-tests, ensuring deptrac.phar can be built You can use the provided Makefile to execute these steps locally. The make command is supported by most major operating systems, but you might need to install it first. The Makefile will use PHIVE to install the required tools like PHPUnit, Psalm or PHPStan. We do not provide these tools as dev-dependencies in composer. If you don't want to use PHIVE or the Makefile you will need to install them yourself.","title":"Pipeline"},{"location":"contributing/#tests","text":"You can run the unit tests locally using the provided Makefile make tests This will run phpunit to make sure the tests pass. We recommend running the tests once before you make any changes to ensure they work on your system. This way you can be sure that any failing test is not caused by a pre-existing problem.","title":"Tests"},{"location":"contributing/#code-style","text":"You can check if your code changes are in line with our coding guidelines using php-cs-fixer. make php-cs-check This will show you any code style violations that are also reported on Github. You can automatically fix them by running: make php-cs-fix","title":"Code style"},{"location":"contributing/#static-code-analysis","text":"In order to perform static code analysis for your changes you can run: make phpstan make psalm We also run a tool called infection for mutation testing: make infection","title":"Static code analysis"},{"location":"contributing/#build-deptrac","text":"You can build the deptrac.phar both to ensure it works, as well as for using it to analyse your existing projects to see if your changes work as expected. make build This will create an executable file deptrac.phar in the current directory.","title":"Build Deptrac"},{"location":"debugging/","text":"Debugging Deptrac provides a series of debug commands that help you identify issues in your depfile. All commands output one issue per line and can therefore be easily combined with other tools like wc or grep . debug:layer With the debug:layer -command you can list all tokens which are matched in a specific layer. php deptrac.phar debug:layer --config-file=examples/DirectoryLayer.depfile.yaml Layer1 examples\\Layer1\\AnotherClassLikeAController examples\\Layer1\\SomeClass examples\\Layer1\\SomeClass2 debug:token The debug:token (previously debug:class-like )-command will let you know which layers a specified token belongs to. php deptrac.phar debug:token --config-file=examples/DirectoryLayer.depfile.yaml 'examples\\Layer1\\AnotherClassLikeAController' class-like Controller Layer1 debug:unassigned With the debug:unassigned -command you list all tokens in your path that are not assigned to any layer. This is useful to test that your collector configuration for layers is correct. php deptrac.phar debug:unassigned --config-file=examples/DirectoryLayer.depfile.yaml examples\\Layer1\\AnotherClassLikeAController examples\\Layer1\\SomeClass examples\\Layer1\\SomeClass2","title":"Debugging"},{"location":"debugging/#debugging","text":"Deptrac provides a series of debug commands that help you identify issues in your depfile. All commands output one issue per line and can therefore be easily combined with other tools like wc or grep .","title":"Debugging"},{"location":"debugging/#debuglayer","text":"With the debug:layer -command you can list all tokens which are matched in a specific layer. php deptrac.phar debug:layer --config-file=examples/DirectoryLayer.depfile.yaml Layer1 examples\\Layer1\\AnotherClassLikeAController examples\\Layer1\\SomeClass examples\\Layer1\\SomeClass2","title":"debug:layer"},{"location":"debugging/#debugtoken","text":"The debug:token (previously debug:class-like )-command will let you know which layers a specified token belongs to. php deptrac.phar debug:token --config-file=examples/DirectoryLayer.depfile.yaml 'examples\\Layer1\\AnotherClassLikeAController' class-like Controller Layer1","title":"debug:token"},{"location":"debugging/#debugunassigned","text":"With the debug:unassigned -command you list all tokens in your path that are not assigned to any layer. This is useful to test that your collector configuration for layers is correct. php deptrac.phar debug:unassigned --config-file=examples/DirectoryLayer.depfile.yaml examples\\Layer1\\AnotherClassLikeAController examples\\Layer1\\SomeClass examples\\Layer1\\SomeClass2","title":"debug:unassigned"},{"location":"depfile/","text":"Depfile The depfile describes your layers, ruleset and other project configuration. imports section If your depfile configuration becomes too large, you can split it up into multiple files that can then be imported in the main depfile using the imports section. Example: imports: - some/depfile.yaml Parameter section analyser count_use_statements This feature is deprecated and will be removed in future release, use types instead. By default, deptrac will analyse all occurrences for classes, including use statements. If you would like to exempt use statements from the analysis, you can change this behaviour in the depfile: parameters: analyser: count_use_statements: false types Deptrac can have different parts of the php file as a source for the dependency. By default, only class definitions and use statements can be the source of the dependency and superglobal variable usage is not tracked. To analyse file more fully, you can define what types of DependencyEmmiters you want to apply on the analysed file: parameters: analyser: types: - use - file - class_superglobal - function_superglobal class (default) - analyses class definitions for everything apart from superglobal usage. class_superglobal - analyses class definitions for superglobal usage. use (default) - analyses file definitions for use statements. file - analyses file for everything apart from use statements and function/class definitions. function - analyses function definitions for everything apart from superglobal usage. function_superglobal - analyses function definitions for superglobal usage. baseline You can define a baseline, i.e. existing violations that should not fail a build. The baseline option takes the filename where the baseline is defined. Example: parameters: baseline: 'deptrac.baseline.yaml' exclude_files With exclude_files you can specify a list of regular expressions for excluding certain files in your path. If any part of the file path matches a regexp defined here, than it will not be collected and added to your layers. Example: parameters: exclude_files: - '#.*Test\\.php$#' formatters Some formatters can be configured to change their output for different purposes. For more info on formatters see Formatters . graphviz You can configure the graphviz output by hiding layers from the output or by grouping them. groups You can group multiple layers. Example: parameters: layers: - User Frontend - User Backend - Admin Frontend - Admin Backend formatters: graphviz: groups: User: - User Frontend - User Backend Admin: - Admin Frontend - Admin Backend The resulting output will look like this: hidden_layers You can hide layers from the generated output. These layers will still be analysed and violations will be reported, but they might no longer be visible in the generated image. Example: parameters: formatters: graphviz: hidden_layers: - Controller ignore_uncovered_internal_classes By default, PHP internal classes will not be reported as uncovered, if they are not covered by a layer. If you want to change this behavior, you can set this option to false. Example: parameters: ignore_uncovered_internal_classes: false layers For more details on layers see the Concepts documentation. Example: parameters: layers: - name: Controller collectors: - type: className regex: .*Controller.* name Each layer must have a unique name. You can use special characters, e.g. () in your names. The YAML format sometimes tries to convert certain characters into types, so you might want to make sure that they are interpreted as string by enclosing the whole name in single quotes, e.g. 'Controller' . collectors For a list of available collectors and their configuration format see Collectors . paths The path option takes a list of directories, that Deptrac should analyse. In most cases, this is where your project's source files are located. You could also add the vendor/ directory if you want to collect any vendor files in layers as well. Example: parameters: paths: - src/ - vendor/ ruleset A ruleset is a list of layer names, which again take a list of layer names. Example: parameters: ruleset: Controller: - Service Service: - Repository Repository: ~ Allowing transitive dependencies If you prepend a layer with + then not only this layer is allowed, but also all layers it allows. In the example below, the Controller can now use classes from the Service and the Repository layer, not just the Service layer. parameters: ruleset: Controller: - +Service Service: - Repository Repository: ~ skip_violations With skip_violations you can tell your CI pipeline to not fail, when the listed violations are encountered. For more on this see Concepts . Example: parameters: skip_violations: Library\\LibClass: - Core\\CoreClass use_relative_path_from_depfile By default, all paths in the configuration are assumed to be relative to the depfile they are defined in. If you want to change this behavior set this option to false. Example: parameters: use_relative_path_from_depfile: false Parameters Deptrac provides parameters that can be user in your configuration. %currentWorkingDirectory% The path Deptrac runs in %depfileDirectory% The path where the depfile is stored. You can specify your own parameters and reuse them in your configuration: Example: parameters: Project: MyProject layers: - name: Foo collectors: - type: implements implements: '%Project%\\SomeInterface'","title":"Depfile"},{"location":"depfile/#depfile","text":"The depfile describes your layers, ruleset and other project configuration.","title":"Depfile"},{"location":"depfile/#imports-section","text":"If your depfile configuration becomes too large, you can split it up into multiple files that can then be imported in the main depfile using the imports section. Example: imports: - some/depfile.yaml","title":"imports section"},{"location":"depfile/#parameter-section","text":"","title":"Parameter section"},{"location":"depfile/#analyser","text":"","title":"analyser"},{"location":"depfile/#count_use_statements","text":"This feature is deprecated and will be removed in future release, use types instead. By default, deptrac will analyse all occurrences for classes, including use statements. If you would like to exempt use statements from the analysis, you can change this behaviour in the depfile: parameters: analyser: count_use_statements: false","title":"count_use_statements"},{"location":"depfile/#types","text":"Deptrac can have different parts of the php file as a source for the dependency. By default, only class definitions and use statements can be the source of the dependency and superglobal variable usage is not tracked. To analyse file more fully, you can define what types of DependencyEmmiters you want to apply on the analysed file: parameters: analyser: types: - use - file - class_superglobal - function_superglobal class (default) - analyses class definitions for everything apart from superglobal usage. class_superglobal - analyses class definitions for superglobal usage. use (default) - analyses file definitions for use statements. file - analyses file for everything apart from use statements and function/class definitions. function - analyses function definitions for everything apart from superglobal usage. function_superglobal - analyses function definitions for superglobal usage.","title":"types"},{"location":"depfile/#baseline","text":"You can define a baseline, i.e. existing violations that should not fail a build. The baseline option takes the filename where the baseline is defined. Example: parameters: baseline: 'deptrac.baseline.yaml'","title":"baseline"},{"location":"depfile/#exclude_files","text":"With exclude_files you can specify a list of regular expressions for excluding certain files in your path. If any part of the file path matches a regexp defined here, than it will not be collected and added to your layers. Example: parameters: exclude_files: - '#.*Test\\.php$#'","title":"exclude_files"},{"location":"depfile/#formatters","text":"Some formatters can be configured to change their output for different purposes. For more info on formatters see Formatters .","title":"formatters"},{"location":"depfile/#graphviz","text":"You can configure the graphviz output by hiding layers from the output or by grouping them.","title":"graphviz"},{"location":"depfile/#groups","text":"You can group multiple layers. Example: parameters: layers: - User Frontend - User Backend - Admin Frontend - Admin Backend formatters: graphviz: groups: User: - User Frontend - User Backend Admin: - Admin Frontend - Admin Backend The resulting output will look like this:","title":"groups"},{"location":"depfile/#hidden_layers","text":"You can hide layers from the generated output. These layers will still be analysed and violations will be reported, but they might no longer be visible in the generated image. Example: parameters: formatters: graphviz: hidden_layers: - Controller","title":"hidden_layers"},{"location":"depfile/#ignore_uncovered_internal_classes","text":"By default, PHP internal classes will not be reported as uncovered, if they are not covered by a layer. If you want to change this behavior, you can set this option to false. Example: parameters: ignore_uncovered_internal_classes: false","title":"ignore_uncovered_internal_classes"},{"location":"depfile/#layers","text":"For more details on layers see the Concepts documentation. Example: parameters: layers: - name: Controller collectors: - type: className regex: .*Controller.*","title":"layers"},{"location":"depfile/#name","text":"Each layer must have a unique name. You can use special characters, e.g. () in your names. The YAML format sometimes tries to convert certain characters into types, so you might want to make sure that they are interpreted as string by enclosing the whole name in single quotes, e.g. 'Controller' .","title":"name"},{"location":"depfile/#collectors","text":"For a list of available collectors and their configuration format see Collectors .","title":"collectors"},{"location":"depfile/#paths","text":"The path option takes a list of directories, that Deptrac should analyse. In most cases, this is where your project's source files are located. You could also add the vendor/ directory if you want to collect any vendor files in layers as well. Example: parameters: paths: - src/ - vendor/","title":"paths"},{"location":"depfile/#ruleset","text":"A ruleset is a list of layer names, which again take a list of layer names. Example: parameters: ruleset: Controller: - Service Service: - Repository Repository: ~","title":"ruleset"},{"location":"depfile/#allowing-transitive-dependencies","text":"If you prepend a layer with + then not only this layer is allowed, but also all layers it allows. In the example below, the Controller can now use classes from the Service and the Repository layer, not just the Service layer. parameters: ruleset: Controller: - +Service Service: - Repository Repository: ~","title":"Allowing transitive dependencies"},{"location":"depfile/#skip_violations","text":"With skip_violations you can tell your CI pipeline to not fail, when the listed violations are encountered. For more on this see Concepts . Example: parameters: skip_violations: Library\\LibClass: - Core\\CoreClass","title":"skip_violations"},{"location":"depfile/#use_relative_path_from_depfile","text":"By default, all paths in the configuration are assumed to be relative to the depfile they are defined in. If you want to change this behavior set this option to false. Example: parameters: use_relative_path_from_depfile: false","title":"use_relative_path_from_depfile"},{"location":"depfile/#parameters","text":"Deptrac provides parameters that can be user in your configuration. %currentWorkingDirectory% The path Deptrac runs in %depfileDirectory% The path where the depfile is stored. You can specify your own parameters and reuse them in your configuration: Example: parameters: Project: MyProject layers: - name: Foo collectors: - type: implements implements: '%Project%\\SomeInterface'","title":"Parameters"},{"location":"formatters/","text":"Formatters Deptrac has support for different output formatters with various options. You can get a list of available formatters by running php deptrac.php analyse --help Baseline Formatter The Baseline formatter is a console formatter, which generates the skip_violations section to the given File. With this formatter it's possible to start on a project with some violations without a failing CI Build. Note : It's not the best solution to ignore all the errors because maybe your current Architecture doesn't allow a change without a new violation. It can be activated with --formatter=baseline . Supported options: --output[=BASELINE-DUMP] path to a dumped baseline file [default: \"./depfile.baseline.yml\"] Don't forget to include the baseline into your existing deptrac.yaml # deptrac.yaml parameters: baseline: depfile.baseline.yml Console Formatter This formatter dumps basic information to STDOUT , examples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller) GitHubActions Formatter The GithubActions formatter is a console formatter, which dumps basic information in github-actions format to STDOUT . This formatter is enabled by default while running in a GitHub actions environment. It can be activated manually with --formatter=github-actions . ::error file=/home/testuser/originalA.php,line=12::ACME\\OriginalA must not depend on ACME\\OriginalB (LayerA on LayerB) Graphviz Formatters There is a whole family of Graphviz formatters for you to choose from depending on what type of output you are expecting. They can be activated with: --formatter=graphviz-display Automatically tries to open the image --formatter=graphviz-dot Saves the output to a .dot file --formatter=graphviz-html Saves the output to a .html file --formatter=graphviz-image Saves the output to a .png file Supported options: --output= path to a dumped file Hide layers in output Under formatters.graphviz.hidden_layers you can define a list of layers you do not want to include when using the corresponding graphviz output formatter. The generated image will not contain these layers, but they will be part of the analysis. There are 2 main use-cases for this feature: Hiding a generic/general domains like the vendor folder Having multiple \"views\" for your architecture. You can define a shared file with all your layers and a ruleset and then have multiple config files for the different hidden_layers . Using the graphviz formatter with these files will then generate graphs focusing on only the relevant layers. parameters: layers: - name: Utils collectors: - type: className regex: .*Util.* - name: Controller collectors: - type: className regex: .*Controller.* ruleset: Controller: - Utils formatters: graphviz: hidden_layers: - Utils Group layers Another supported option is formatters.graphviz.groups . There you can sort layers into groups that will be rendered as sub-graphs in GraphViz output. The following config: parameters: layers: - User Frontend - User Backend - Admin Frontend - Admin Backend formatters: graphviz: groups: User: - User Frontend - User Backend Admin: - Admin Frontend - Admin Backend Will produce the following graph: Pointing to groups instead of nodes With formatters.graphviz.pointToGroups set to true , when you have a node inside a groups with the same name as the group itself, edges pointing to that node will point to the group instead. This might be useful for example if you want to provide a \"public API\" for a module defined by a group. JSON Formatter By default, Json formatter dumps information to STDOUT . It can be activated with --formatter=json { \"Report\": { \"Violations\": 1, \"Skipped violations\": 2, \"Uncovered\": 1, \"Allowed\": 0, \"Warnings\": 0, \"Errors\": 0 }, \"files\": { \"src/ClassA.php\": { \"violations\": 2, \"messages\": [ { \"message\": \"ClassA must not depend on ClassB (LayerA on LayerB)\", \"line\": 12, \"type\": \"error\" }, { \"message\": \"ClassA should not depend on ClassC (LayerA on LayerB)\", \"line\": 15, \"type\": \"warning\" } ] }, \"src/ClassC.php\": { \"violations\": 1, \"messages\": [ { \"message\": \"ClassC should not depend on ClassD (LayerA on LayerB)\", \"line\": 10, \"type\": \"warning\" } ] }, \"src/OriginalA.php\": { \"violations\": 1, \"messages\": [ { \"message\": \"OriginalA has uncovered dependency on OriginalB (LayerA)\", \"line\": 5, \"type\": \"warning\" } ] } } } Supported options: --output= path to a dumped json file JUnit Formatter The JUnit formatter dumps a JUnit Report XML file, which is quite handy in CI environments. It is disabled by default, to activate the formatter just use --formatter=junit . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <testsuites> <testsuite id=\"1\" package=\"\" name=\"Controller\" timestamp=\"2018-06-07T10:09:34+00:00\" hostname=\"localhost\" tests=\"3\" failures=\"2\" errors=\"0\" time=\"0\"> <testcase name=\"Controller-examples\\Layer1\\AnotherClassLikeAController\" classname=\"examples\\Layer1\\AnotherClassLikeAController\" time=\"0\"> <failure message=\"examples\\Layer1\\AnotherClassLikeAController:5 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\" type=\"WARNING\" /> <failure message=\"examples\\Layer1\\AnotherClassLikeAController:23 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\" type=\"WARNING\" /> </testcase> </testsuite> <testsuite id=\"2\" package=\"\" name=\"Layer2\" timestamp=\"2018-06-07T10:09:34+00:00\" hostname=\"localhost\" tests=\"3\" failures=\"4\" errors=\"0\" time=\"0\"> <testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass2\" classname=\"examples\\Layer2\\SomeOtherClass2\" time=\"0\"> <failure message=\"examples\\Layer2\\SomeOtherClass2:5 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\" type=\"WARNING\" /> <failure message=\"examples\\Layer2\\SomeOtherClass2:17 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\" type=\"WARNING\" /> </testcase> <testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass\" classname=\"examples\\Layer2\\SomeOtherClass\" time=\"0\"> <failure message=\"examples\\Layer2\\SomeOtherClass:5 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\" type=\"WARNING\" /> <failure message=\"examples\\Layer2\\SomeOtherClass:17 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\" type=\"WARNING\" /> </testcase> </testsuite> </testsuites> Supported options: --output= path to a dumped xml file [default: \"./junit-report.xml\"] Table Formatter The default formatter is the table formatter, which groups results by layers to its own table. It can be also activated with --formatter=table .","title":"Formatters"},{"location":"formatters/#formatters","text":"Deptrac has support for different output formatters with various options. You can get a list of available formatters by running php deptrac.php analyse --help","title":"Formatters"},{"location":"formatters/#baseline-formatter","text":"The Baseline formatter is a console formatter, which generates the skip_violations section to the given File. With this formatter it's possible to start on a project with some violations without a failing CI Build. Note : It's not the best solution to ignore all the errors because maybe your current Architecture doesn't allow a change without a new violation. It can be activated with --formatter=baseline . Supported options: --output[=BASELINE-DUMP] path to a dumped baseline file [default: \"./depfile.baseline.yml\"] Don't forget to include the baseline into your existing deptrac.yaml # deptrac.yaml parameters: baseline: depfile.baseline.yml","title":"Baseline Formatter"},{"location":"formatters/#console-formatter","text":"This formatter dumps basic information to STDOUT , examples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller)","title":"Console Formatter"},{"location":"formatters/#githubactions-formatter","text":"The GithubActions formatter is a console formatter, which dumps basic information in github-actions format to STDOUT . This formatter is enabled by default while running in a GitHub actions environment. It can be activated manually with --formatter=github-actions . ::error file=/home/testuser/originalA.php,line=12::ACME\\OriginalA must not depend on ACME\\OriginalB (LayerA on LayerB)","title":"GitHubActions Formatter"},{"location":"formatters/#graphviz-formatters","text":"There is a whole family of Graphviz formatters for you to choose from depending on what type of output you are expecting. They can be activated with: --formatter=graphviz-display Automatically tries to open the image --formatter=graphviz-dot Saves the output to a .dot file --formatter=graphviz-html Saves the output to a .html file --formatter=graphviz-image Saves the output to a .png file Supported options: --output= path to a dumped file","title":"Graphviz Formatters"},{"location":"formatters/#hide-layers-in-output","text":"Under formatters.graphviz.hidden_layers you can define a list of layers you do not want to include when using the corresponding graphviz output formatter. The generated image will not contain these layers, but they will be part of the analysis. There are 2 main use-cases for this feature: Hiding a generic/general domains like the vendor folder Having multiple \"views\" for your architecture. You can define a shared file with all your layers and a ruleset and then have multiple config files for the different hidden_layers . Using the graphviz formatter with these files will then generate graphs focusing on only the relevant layers. parameters: layers: - name: Utils collectors: - type: className regex: .*Util.* - name: Controller collectors: - type: className regex: .*Controller.* ruleset: Controller: - Utils formatters: graphviz: hidden_layers: - Utils","title":"Hide layers in output"},{"location":"formatters/#group-layers","text":"Another supported option is formatters.graphviz.groups . There you can sort layers into groups that will be rendered as sub-graphs in GraphViz output. The following config: parameters: layers: - User Frontend - User Backend - Admin Frontend - Admin Backend formatters: graphviz: groups: User: - User Frontend - User Backend Admin: - Admin Frontend - Admin Backend Will produce the following graph:","title":"Group layers"},{"location":"formatters/#pointing-to-groups-instead-of-nodes","text":"With formatters.graphviz.pointToGroups set to true , when you have a node inside a groups with the same name as the group itself, edges pointing to that node will point to the group instead. This might be useful for example if you want to provide a \"public API\" for a module defined by a group.","title":"Pointing to groups instead of nodes"},{"location":"formatters/#json-formatter","text":"By default, Json formatter dumps information to STDOUT . It can be activated with --formatter=json { \"Report\": { \"Violations\": 1, \"Skipped violations\": 2, \"Uncovered\": 1, \"Allowed\": 0, \"Warnings\": 0, \"Errors\": 0 }, \"files\": { \"src/ClassA.php\": { \"violations\": 2, \"messages\": [ { \"message\": \"ClassA must not depend on ClassB (LayerA on LayerB)\", \"line\": 12, \"type\": \"error\" }, { \"message\": \"ClassA should not depend on ClassC (LayerA on LayerB)\", \"line\": 15, \"type\": \"warning\" } ] }, \"src/ClassC.php\": { \"violations\": 1, \"messages\": [ { \"message\": \"ClassC should not depend on ClassD (LayerA on LayerB)\", \"line\": 10, \"type\": \"warning\" } ] }, \"src/OriginalA.php\": { \"violations\": 1, \"messages\": [ { \"message\": \"OriginalA has uncovered dependency on OriginalB (LayerA)\", \"line\": 5, \"type\": \"warning\" } ] } } } Supported options: --output= path to a dumped json file","title":"JSON Formatter"},{"location":"formatters/#junit-formatter","text":"The JUnit formatter dumps a JUnit Report XML file, which is quite handy in CI environments. It is disabled by default, to activate the formatter just use --formatter=junit . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <testsuites> <testsuite id=\"1\" package=\"\" name=\"Controller\" timestamp=\"2018-06-07T10:09:34+00:00\" hostname=\"localhost\" tests=\"3\" failures=\"2\" errors=\"0\" time=\"0\"> <testcase name=\"Controller-examples\\Layer1\\AnotherClassLikeAController\" classname=\"examples\\Layer1\\AnotherClassLikeAController\" time=\"0\"> <failure message=\"examples\\Layer1\\AnotherClassLikeAController:5 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\" type=\"WARNING\" /> <failure message=\"examples\\Layer1\\AnotherClassLikeAController:23 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\" type=\"WARNING\" /> </testcase> </testsuite> <testsuite id=\"2\" package=\"\" name=\"Layer2\" timestamp=\"2018-06-07T10:09:34+00:00\" hostname=\"localhost\" tests=\"3\" failures=\"4\" errors=\"0\" time=\"0\"> <testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass2\" classname=\"examples\\Layer2\\SomeOtherClass2\" time=\"0\"> <failure message=\"examples\\Layer2\\SomeOtherClass2:5 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\" type=\"WARNING\" /> <failure message=\"examples\\Layer2\\SomeOtherClass2:17 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\" type=\"WARNING\" /> </testcase> <testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass\" classname=\"examples\\Layer2\\SomeOtherClass\" time=\"0\"> <failure message=\"examples\\Layer2\\SomeOtherClass:5 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\" type=\"WARNING\" /> <failure message=\"examples\\Layer2\\SomeOtherClass:17 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\" type=\"WARNING\" /> </testcase> </testsuite> </testsuites> Supported options: --output= path to a dumped xml file [default: \"./junit-report.xml\"]","title":"JUnit Formatter"},{"location":"formatters/#table-formatter","text":"The default formatter is the table formatter, which groups results by layers to its own table. It can be also activated with --formatter=table .","title":"Table Formatter"}]}